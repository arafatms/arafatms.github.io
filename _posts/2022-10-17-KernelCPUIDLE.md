---
layout: post
title: 【内核】CPU IDLE
date: 2022-12-06
tags: 内核
---

[参考1](https://zhuanlan.zhihu.com/p/548268554)

[参考2 Documentation/admin-guide/pm/cpuidle.rst]()

## 介绍

现代处理器通常能够进入暂停执行程序并且不从内存中获取或执行属于该程序的指令的状态。 这些状态是处理器的*空闲*状态。

由于部分处理器硬件未在空闲状态下使用，因此进入空闲状态通常可以减少处理器消耗的功率，因此，这是一个节省能源的机会。

CPU 空闲时间管理是一项节能功能，涉及为此目的使用处理器的空闲状态。

## Logical CPUs

CPU 空闲时间管理在 CPU 上运行，正如 *CPU 调度程序* 所见（即负责在系统中分配计算工作的内核部分）。 在它看来，CPU 是*逻辑*单元。 也就是说，它们不需要是单独的物理实体，而可能只是对软件表现为单独的单核处理器的接口。 换句话说，CPU 是一个实体，它看起来是从内存中获取属于一个序列（程序）的指令并执行它们，但它不需要在物理上以这种方式工作。 通常，这里可以考虑三种不同的情况。

首先，如果整个处理器一次只能执行一个指令序列（一个程序），那么它就是一个 CPU。 在这种情况下，如果硬件被要求进入空闲状态，则整个处理器都会受到影响。

其次，如果处理器是多核的，那么其中的每个内核一次至少可以执行一个程序。 内核不需要彼此完全独立（例如，它们可以共享缓存），但大多数时候它们仍然在物理上彼此并行工作，因此如果它们每个只执行一个程序，那么这些程序大部分都是独立运行的 彼此同时。 在这种情况下，整个内核都是 CPU，如果硬件被要求进入空闲状态，这适用于首先请求它的内核，但它也可能适用于更大的单元（比如“包”或 核心所属的“集群”）（事实上，它可能适用于包含核心的更大单元的整个层次结构）。 也就是说，如果较大单元中除一个内核之外的所有内核都已在“内核级别”进入空闲状态，而其余内核要求处理器进入空闲状态，则可能会触发它使整个较大单元进入 空闲状态也会影响该单元中的其他内核。

最后，多核处理器中的每个内核可能能够在同一时间范围内执行多个程序（也就是说，每个内核可能能够从内存中的多个位置获取指令并在同一时间范围内执行它们， 但不一定完全平行）。 在那种情况下，核心将自己呈现给软件作为“捆绑包”，每个捆绑包由多个单独的单核“处理器”组成，称为*硬件线程*（或英特尔硬件上的超线程），每个可以遵循一个序列 指示。 然后，从 CPU 空闲时间管理的角度来看，硬件线程是 CPU，如果其中之一要求处理器进入空闲状态，则请求它的硬件线程（或 CPU）将停止，但不会再发生任何事情，除非 同一个内核中的所有其他硬件线程也要求处理器进入空闲状态。 在这种情况下，核心可能会单独进入空闲状态，或者包含它的更大单元可能会作为一个整体进入空闲状态（如果较大单元中的其他核心已经处于空闲状态）。

## Idle CPUs

逻辑 CPU，在下文中简称为“CPU”，当除了特殊的“空闲”任务外没有任何任务可在其上运行时，Linux 内核将其视为*空闲*。

任务是 CPU 调度程序的工作表示。 每个任务都包含一系列执行指令或编码、运行该代码时要操作的数据，以及每次 CPU 运行任务代码时需要加载到处理器中的一些上下文信息。 CPU 调度程序通过将要运行的任务分配给系统中存在的 CPU 来分配工作。

任务可以处于各种状态。 特别是，如果没有特定条件阻止它们的代码由 CPU 运行，只要有可用的 CPU（例如，它们不等待任何事件发生或类似事件），它们就是“可运行的”。 当一个任务变得可运行时，CPU 调度程序将它分配给一个可用的 CPU 来运行，如果没有更多可运行的任务分配给它，CPU 将加载给定任务的上下文并运行它的代码（从最后一个指令之后的指令开始） 到目前为止执行的一个，可能由另一个 CPU 执行）。 [如果有多个可运行的任务同时分配给一个 CPU，它们将进行优先级排序和时间共享，以便让它们随着时间的推移取得一些进展。]

如果没有其他可运行的任务分配给给定的 CPU，则特殊的“空闲”任务变为可运行，然后该 CPU 被视为空闲。 换句话说，在 Linux 中，空闲 CPU 运行称为“空闲循环”的“空闲”任务的代码。 该代码可能会导致处理器进入其空闲状态之一（如果支持）以节省能源，但如果处理器不支持任何空闲状态，或者没有足够的时间处于空闲状态 在下一个唤醒事件之前，或者有严格的延迟限制阻止使用任何可用的空闲状态，CPU 将简单地在循环中执行或多或少无用的指令，直到它被分配一个新的任务来运行。

## The Idle Loop

空闲循环代码在它的每次迭代中都采取两个主要步骤。 首先，它调用一个称为*governor* 的代码模块，该代码模块属于称为“CPUIdle”的CPU 空闲时间管理子系统，以选择CPU 要求硬件进入的空闲状态。 其次，它调用来自 ``CPUIdle`` 子系统的另一个代码模块，称为 *driver*，实际要求处理器硬件进入调控器选择的空闲状态。

<img src="/images/posts/20221206-CPUIDLE/driver.jpeg" width="700px" />

调速器的作用是找到最适合手头条件的空闲状态。 为此，逻辑 CPU 要求硬件进入的空闲状态以独立于平台或处理器架构的抽象方式表示，并组织在一维（线性）数组中。 该数组必须由与内核在初始化时运行的平台相匹配的“CPUIdle”驱动程序准备和提供。 这允许 ``CPUIdle`` 调控器独立于底层硬件，并与 Linux 内核可以运行的任何平台一起工作。

该阵列中存在的每个空闲状态都由两个参数表征，这些参数将由调控器考虑，即*目标驻留(target residency)*和（最坏情况）*退出延迟(exit latency)*。 目标驻留时间是硬件必须在给定状态下花费的最短时间，包括进入该状态所需的时间（可能很长），以便比进入较浅的空闲状态之一节省更多的能量。 [空闲状态的“深度”大致对应于处理器在该状态下消耗的功率。]退出延迟反过来是 CPU 要求处理器硬件进入空闲状态以启动所需的最长时间 从该状态唤醒后执行第一条指令。 请注意，通常退出延迟还必须涵盖进入给定状态所需的时间，以防在硬件进入给定状态时发生唤醒，并且必须完全进入才能以有序方式退出。

有两种类型的信息可以影响governor的决定。 首先，governor 知道最近的定时器事件的时间。 那个时间是确切知道的，因为内核编程定时器并且它确切知道它们何时触发，它是给定 CPU 所依赖的硬件可以处于空闲状态的最长时间，包括进入和退出它所需的时间 . 然而，CPU 可能随时被非定时器事件唤醒（特别是在最近的定时器触发之前），并且通常不知道何时会发生。 调控器只能看到 CPU 在被唤醒后实际空闲了多少时间（从现在开始，这段时间将被称为*空闲持续时间idle duration*），并且它可以以某种方式使用该信息以及时间，直到最接近 定时器来估计未来的空闲持续时间。 调控器如何使用该信息取决于它实现的算法，这是在 ``CPUIdle`` 子系统中拥有多个调控器的主要原因。

主流linux倍和中有三个调速器可用：
- menu
- tue
- ladder
如果传入cpuidle_sysfs_switch内核参数可以动态调整调速器，但这个很不安全，不建议在生产环境里使用。所使用的调速器通过如下方法查看
```
cat /sys/devices/system/cpu/cpuidle/current_governor_ro
```

另一方面，使用哪个 ``CPUIdle`` 驱动程序通常取决于内核运行的平台，但有些平台具有多个匹配的驱动程序。 例如，有两个驱动程序可以与大多数英特尔平台一起工作，“intel_idle”和“acpi_idle”，一个具有硬编码的空闲状态信息，另一个能够分别从系统的 ACPI 表中读取该信息 . 尽管如此，即使在这些情况下，在系统初始化时选择的驱动程序以后也无法替换，因此必须尽早决定使用其中的一个（在 Intel 平台上，如果出现以下情况，将使用 ``acpi_idle`` 驱动程序 ``intel_idle`` 由于某种原因或如果它无法识别处理器而被禁用）。 内核当前使用的``CPUIdle`` 驱动的名称可以从``sysfs`` 中:file:`/sys/devices/system/cpu/cpuidle/` 下的:file:`current_driver` 文件中读取 .

## Idle CPUs and The Scheduler Tick

scheduler tick是一个定时器，它周期性地触发，以实现CPU调度器的分时策略。 当然，如果有多个可运行任务同时分配给一个 CPU，那么让它们在给定的时间范围内取得合理进展的唯一方法就是让它们共享可用的 CPU 时间。 也就是说，在粗略的近似中，每个任务都被赋予一段 CPU 时间来运行其代码，受制于调度类、优先级等，当该时间片用完时，CPU 应该切换到运行（ 代码）另一个任务。 然而，当前正在运行的任务可能不想主动放弃 CPU，并且调度程序 tick 可以使切换发生。 这不是滴答声的唯一作用，但却是使用它的主要原因.

从 CPU 空闲时间管理的角度来看，调度程序节拍是有问题的，因为它周期性且相对频繁地触发（根据内核配置，节拍周期的长度在 1 毫秒到 10 毫秒之间）。 因此，如果允许在空闲 CPU 上触发节拍，则它们要求硬件进入目标驻留时间超过节拍周期长度的空闲状态是没有意义的。 此外，在那种情况下，任何 CPU 的空闲持续时间都不会超过滴答周期长度，并且由于空闲 CPU 上的滴答唤醒而用于进入和退出空闲状态的能量将被浪费。

幸运的是，并不是真的有必要让 tick 在空闲 CPU 上触发，因为（根据定义）除了特殊的“空闲”任务外，它们没有要运行的任务。 换句话说，从 CPU 调度程序的角度来看，CPU 时间的唯一使用者是空闲循环。 由于空闲 CPU 的时间不需要在多个可运行任务之间共享，如果给定的 CPU 空闲，使用 tick 的主要原因就会消失。 因此，原则上可以在空闲 CPU 上完全停止调度程序滴答，尽管这可能并不总是值得付出努力。

在空闲循环中停止调度器滴答是否有意义取决于调控器的期望。 首先，如果有另一个（非滴答）计时器由于在滴答范围内触发，显然停止滴答将是浪费时间，即使在这种情况下可能不需要重新编程定时器硬件。 其次，如果 governor 期望在 tick 范围内进行非定时器唤醒，则停止 tick 是没有必要的，甚至可能是有害的。 也就是说，在这种情况下，governor 将在预期唤醒之前的时间内选择具有目标驻留时间的空闲状态，因此该状态将相对较浅。 那时管理者真的不能选择深度空闲状态，因为那会与其自己对在短时间内唤醒的期望相矛盾。 现在，如果唤醒真的很快发生，停止滴答将是浪费时间，在这种情况下，定时器硬件将需要重新编程，这是昂贵的。 另一方面，如果 tick 停止并且唤醒不会很快发生，硬件可能会在 governor 选择的 shallow idle 状态中花费无限长的时间，这将是一种能源浪费。 因此，如果调控器期望在 tick 范围内发生任何类型的唤醒，最好允许 tick 触发。 然而，否则，调控器将选择一个相对较深的空闲状态，因此应停止滴答，以免过早唤醒 CPU。

无论如何，governor 知道它在期待什么，是否停止 scheduler tick 的决定权属于它。 尽管如此，如果 tick 已经停止（在循环的前一次迭代中），最好让它保持原样，并且调控器需要考虑到这一点。

内核可以配置为完全禁用停止空闲循环中的调度程序滴答。 这可以通过它的构建时配置（通过取消设置 ``CONFIG_NO_HZ_IDLE`` 配置选项）或通过在命令行中将 ``nohz=off`` 传递给它来完成。 在这两种情况下，由于禁用了调度程序节拍的停止，因此空闲循环代码简单地忽略了调控器有关它的决定，并且节拍永远不会停止。

运行内核的系统被配置为允许在空闲 CPU 上停止调度程序节拍被称为*无节拍*系统，它们通常被认为比运行节拍不能停止的内核的系统更节能。 如果给定的系统是无滴答的，它将默认使用``menu``调控器，如果它不是无滴答的，则默认的``CPUIdle``调控器将是``ladder``。

## The ``menu`` Governor

``menu`` 调控器是无滴答系统的默认 ``CPUIdle`` 调控器。 它相当复杂，但其设计的基本原理很简单。 即，当调用以选择 CPU 的空闲状态（即 CPU 将要求处理器硬件进入的空闲状态）时，它会尝试预测空闲持续时间并使用预测值来选择空闲状态。

它首先获取到最近的计时器事件的时间，并假设调度程序滴答将停止。 该时间在下文中称为*睡眠长度*，是下一次 CPU 唤醒之前的时间上限。 它用于确定睡眠长度范围，进而需要获得睡眠长度校正因子。

``menu`` 调控器维护两个睡眠长度校正因子数组。 当先前在给定 CPU 上运行的任务正在等待某些 I/O 操作完成时使用其中一个，而在不是这种情况时使用另一个。 每个数组包含多个校正因子值，这些值对应于组织的不同睡眠长度范围，因此数组中表示的每个范围比前一个范围宽大约 10 倍。
```
menu_enable_device
    |
    o -> correction_factor[i] = RESOLUTION * DECAY; // RESOLUTION = 1024, DECAY = 8
```

给定睡眠长度范围的校正因子（在为 CPU 选择空闲状态之前确定）在 CPU 被唤醒后更新，睡眠长度越接近观察到的空闲持续时间，校正因子就越接近 1 （它必须介于 0 和 1 之间）。 睡眠长度乘以其所属范围的校正因子以获得预测空闲持续时间的第一近似值。退出IDLE状态后将上一次进入IDLE状态的数据更新到driver中的相关数据中。

### 更新driver数据 menu_reflect

```
    dev->last_state_idx = index; // 上次idle状态
	data->needs_update = 1; // 下次select时需要更新矫正因子
	data->tick_wakeup = tick_nohz_idle_got_tick();  // 记录是否是tick唤醒
```

### 更新矫正因子 menu_update

```
menu_update //attempts to guess what happened after entry
    |
    o -> 尝试算出进入idle状态到倍唤醒经历了多长时间 measured_us
            |
            o -> cpu 被tick唤醒，而且睡眠时间超过了一个tick周期，就会假定cpu空闲了很长时间, measured_us=9 * MAX_INTERESTING / 10（INTERESTING=50000)
            |
            o -> cpu退出poll，会导致该状态的空闲时间不准，会将下次tick间隔(next_timer_us)作为measured_us
            |
            o -> else: 上次留存时间(last_residency 从进入idle和退出idle的真实事件差)作为measured时间, 并且根据exit_latency去矫正
    |
    o -> 保证measured_us不要超过next_timer_us
    o -> 取measured_us和next_timer_us最小值
    |
    o -> 矫正因子衰变一次
    |
    o -> 更新矫正因子和间隔数据
```

接下来，调控器使用一种简单的模式识别算法来完善其闲置持续时间预测。 即，它保存最后 8 个观察到的闲置持续时间值，并在下次预测闲置持续时间时，计算它们的平均值和方差。 如果方差很小（小于 400 平方毫秒）或相对于平均值较小（平均值大于标准差的 6 倍），则平均值被视为“典型区间”值。 否则，丢弃最长的已保存观察空闲持续时间值，并对其余值重复计算。 同样，如果它们的方差较小（在上述意义上），则取平均值作为“典型区间”值，依此类推，直到确定“典型区间”或忽略太多数据点，其中 假设“典型间隔”等于“无穷大”（最大无符号整数值）。 将以这种方式计算的“典型间隔”与睡眠长度乘以校正因子进行比较，并将两者中的最小值作为预测的空闲持续时间。

然后，调控器计算额外的延迟限制以帮助“交互式”工作负载。 它使用的观察结果是，如果所选空闲状态的退出延迟与预测的空闲持续时间相当，则在该状态下花费的总时间可能会很短，进入该状态所节省的能量也相对较小，因此 可能最好避免与进入该状态和退出该状态相关的开销。 因此，选择较浅的状态可能是一个更好的选择。 额外延迟限制的第一个近似值是预测的空闲持续时间本身，它另外除以一个值，该值取决于先前在给定 CPU 上运行的任务数量，现在它们正在等待 I/O 操作完成。 将该划分的结果与来自电源管理服务质量的延迟限制或 `PM QoS <cpu-pm-qos_>`_ 框架进行比较，并将两者中的最小值作为空闲状态的限制退出延迟。

现在，调控器准备遍历空闲状态列表并选择其中之一。 为此，它将每个状态的目标驻留与预测的空闲持续时间以及它的退出延迟与计算的延迟限制进行比较。 它选择目标驻留最接近预测空闲持续时间但仍低于它的状态，并且退出延迟不超过限制。

在最后一步中，如果 governor 还没有决定停止调度程序 tick <idle-cpus-and-tick_>`_，它可能仍然需要优化空闲状态选择。 如果它预测的空闲持续时间小于滴答周期并且滴答尚未停止（在空闲循环的前一次迭代中），则会发生这种情况。 然后，之前计算中使用的睡眠长度可能无法反映实际时间，直到最接近的计时器事件发生，如果它确实大于该时间，则调控器可能需要选择具有合适目标驻留的较浅状态。