---
layout: post
title: 【AMD64开发手册】八，异常和中断
date: 2021-9-23
tags: AMD64开发手册    
---

# Exceptions and Interrupts

Exceptions and interrupts force control transfers from the currently-executing program to a systemsoftware service routine that handles the interrupting event. These routines are referred to as exception handlers and interrupt handlers, or collectively as event handlers. Typically, interrupt events can be handled by the service routine transparently to the interrupted program. During the control transfer to the service routine, the processor stops executing the interrupted program and saves its return pointer. The system-software service routine that handles the exception or interrupt is responsible for saving the state of the interrupted program. This allows the processor to restart the interrupted program after system software has handled the event.

When an exception or interrupt occurs, the processor uses the interrupt vector number as an index into the interrupt-descriptor table (IDT).

Exceptions and interrupts come from three general sources:
- Exceptions occur as a result of software execution errors or other internal-processor errors. Exceptions also occur during non-error situations, such as program single stepping or addressbreakpoint detection. Exceptions are considered synchronous events because they are a direct result of executing the interrupted instruction.
- Software interrupts occur as a result of executing interrupt instructions. Like exceptions, software interrupts are synchronous events.
- External interrupts are generated by system logic in response to an error or some other event outside the processor.

## General Characteristics
Exceptions and interrupts have several different characteristics that depend on how events are reported and the implications for program restart.

### Precision 精确性
Precision describes how the exception is related to the interrupted program:
- Precise exceptions are reported on a predictable instruction boundary. All previous instructions are allowed to complete before transferring control to the event handler.When the event handler completes execution, it returns to the interrupted program and restarts execution at the interrupted-instruction boundary.
- Imprecise exceptions are not guaranteed to be reported on a predictable instruction boundary. The interrupted program is not restartable.

### Instruction Restart
As mentioned above, precise exceptions are reported on an instruction boundary. The instruction boundary can be reported in one of two locations:
- Most exceptions report the boundary before the instruction causing the exception. In this case, all previous instructions (in program order) are allowed to complete, but the interrupted instruction is not.
- Some exceptions report the boundary after the instruction causing the exception. In this case, all previous instructions—including the one executing when the exception occurred—are allowed to complete.
Program state can be updated when the reported boundary is after the instruction causing the exception.

### Types of Exceptions
There are three types of exceptions, depending on whether they are precise and how they affect program restart:
- Faults are precise exceptions reported on the boundary before the instruction causing the exception. the instruction can be restarted. The saved rIP points to the faulting instruction.
- Traps are precise exceptions reported on the boundary following the instruction causing the exception.
- Aborts are imprecise exceptions. Because they are imprecise, aborts typically do not allow reliable program restart.

### Masking External Interrupts
General Masking Capabilities. Software can mask the occurrence of certain exceptions and interrupts. Masking can delay or even prevent triggering of the exception-handling or interrupthandling mechanism when an interrupt-event occurs. External interrupts are classified as maskable or nonmaskable:
- Maskable interrupts trigger the interrupt-handling mechanism only when RFLAGS.IF=1. Otherwise they are held pending for as long as the RFLAGS.IF bit is cleared to 0. 
- Nonmaskable interrupts (NMI) are unaffected by the value of the RFLAGS.IF bit.

## Vectors
Specific exception and interrupt sources are assigned a fixed vector-identification number (also called an “interrupt vector” or simply “vector”). The interrupt vector is used by the interrupt-handling mechanism to locate the system-software service routine assigned to the exception or interrupt. Up to 256 unique interrupt vectors are available. The first 32 vectors are reserved for predefined exception and interrupt conditions. Software-interrupt sources can trigger an interrupt using any available interrupt vector.

前32个中断向量见AMD开发手册，挑选几个重点讲述：

### NMI—Non-Maskable-Interrupt Exception (Vector 2)
An NMI exception occurs as a result of system logic signaling a non-maskable interrupt to the processor.
Error Code Returned. None.
Program Restart. NMI is an interrupt. The processor recognizes an NMI at an instruction boundary. The saved instruction pointer points to the instruction immediately following the boundary where the NMI was recognized.
Masking. NMI cannot be masked. However, when an NMI is recognized by the processor, recognition of subsequent NMIs are disabled until an IRET instruction is executed.

### PF—Page-Fault Exception (Vector 14)
A #PF exception can occur during a memory access in any of the following situations:
- A page-translation-table entry or physical page involved in translating the memory access is not present in physical memory. This is indicated by a cleared present bit (P=0) in the translation-table entry.
- An attempt is made by the processor to load the instruction TLB with a translation for a nonexecutable page.
- The memory access fails the paging-protection checks (user/supervisor, read/write, or both).
- A reserved bit in one of the page-translation-table entries is set to 1. A #PF occurs for this reason only when CR4.PSE=1 or CR4.PAE=1.
- A data access to a user-mode address caused a protection key violation.
PF cannot be disabled.
The virtual (linear) address that caused the #PF is stored in the CR2 register.
Error Code Returned. The page-fault error code is pushed onto the page-fault exception-handler stack.

### User-Defined Interrupts (Vectors 32–255)
User-defined interrupts can be initiated either by system logic or software. They occur when:
- System logic signals an external interrupt request to the processor. The signaling mechanism and the method of communicating the interrupt vector to the processor are implementation dependent.
- Software executes an INTn instruction. The INTn instruction operand provides the interrupt vector number.
Both methods can be used to initiate an interrupt into vectors 0 through 255. However, because vectors 0 through 31 are defined or reserved by the AMD64 architecture, software should not use vectors in this range for purposes other than their defined use.
Masable.

## Error Codes
The processor exception-handling mechanism reports error and status information for some exceptions using an error code. The error code is pushed onto the stack by the exception mechanism during the control transfer into the exception handler. The error code formats are described in the following sections.

## Priorities
To allow for consistent handling of multiple-interrupt conditions, simultaneous interrupts are prioritized by the processor.
When simultaneous interrupts occur, the processor transfers control to the highest-priority interrupt handler. Lower-priority interrupts from external sources are held pending by the processor, and they are handled after the higher-priority interrupt is handled.
具体优先级见AMD开发手册

### External Interrupt Priorities
The AMD64 architecture allows software to define up to 15 external interrupt-priority classes. Priority classes are numbered from 1 to 15, with priority-class 1 being the lowest and priority-class 15 the highest. The organization of these priority classes is implementation dependent. A typical method is to use the upper four bits of the interrupt vector number to define the priority. Thus, interrupt vector 53h has a priority of 5 and interrupt vector 37h has a priority of 3.

A new control register (CR8) is introduced by the AMD64 architecture for managing priority classes. This register, called the task-priority register (TPR), uses its four low-order bits to specify a task priority. System software can use the TPR register to temporarily block low-priority interrupts from interrupting a high-priority task. For example, loading TPR with a value of 9 (1001b) blocks all interrupts with a priority class of 9 or less, while allowing all interrupts with a priority class of 10 or more to be recognized.
The TPR is an architectural abstraction of the interrupt controller (IC), which prioritizes and manages external interrupt delivery to the processor. The IC can be an external system device, or it can be integrated on the chip like the local advanced programmable interrupt controller (APIC).

## Long-Mode Interrupt Control Transfers
When an interrupt occurs in long mode, the processor multiplies the interrupt vector number by 16 and uses the result as an offset into the IDT. The gate descriptor referenced by the IDT offset contains a segment-selector and a 64-bit segment-offset field. The gate-descriptor segment-offset field contains the complete virtual address for the interrupt handler. The gate-descriptor segment-selector field points to the target code-segment descriptor located in either the GDT or LDT. The code-segment descriptor is only used for privilege-checking purposes and for placing the processor in 64-bit mode. The code segment-descriptor base field, limit field, and most attributes are ignored.

![avatar](https://raw.githubusercontent.com/arafatms/arafatms.github.io/main/images/posts/20210923-AMDExceptionsAndInterrupts/LongModeInterruptControlTransfer.png?raw=true)

In long mode, the return-program stack pointer (SS:RSP) is always pushed onto the interrupt-handler stack, regardless of whether or not a privilege change occurs.
In long mode, when a control transfer to an interrupt handler occurs, the processor performs the following:
1. Aligns the new interrupt-stack frame by masking RSP with FFFF_FFFF_FFFF_FFF0h.
2. If IST field in interrupt gate is not 0, reads IST pointer into RSP.
3. If a privilege change occurs, the target DPL is used as an index into the long-mode TSS to select a new stack pointer (RSP).
4. If a privilege change occurs, SS is cleared to zero indicating a null selector.
5. Pushes the return stack pointer (old SS:RSP) onto the new stack. The SS value is padded with six bytes to form a quadword.
6. Pushes the 64-bit RFLAGS register onto the stack. The upper 32 bits of the RFLAGS image on the stack are written as zeros.
7. Clears the TF, NT, and RF bits in RFLAGS bits to 0.
8. Handles the RFLAGS.IF bit according to the gate-descriptor type:
    - If the gate descriptor is an interrupt gate, RFLAGS.IF is cleared to 0.
    - If the gate descriptor is a trap gate, RFLAGS.IF is not modified.
9. Pushes the return CS register and RIP register onto the stack. The CS value is padded with six bytes to form a quadword.
10. If the interrupt vector number has an error code associated with it, pushes the error code onto the stack. The error code is padded with four bytes to form a quadword.
11. Loads the segment-selector field from the gate descriptor into the CS register. The processor checks that the target code-segment is a 64-bit mode code segment.
12. Loads the offset field from the gate descriptor into the target RIP. The interrupt handler begins execution when control is transferred to the instruction referenced by the new RIP.

![avatar](https://raw.githubusercontent.com/arafatms/arafatms.github.io/main/images/posts/20210923-AMDExceptionsAndInterrupts/LongModeStackAfterInterruptSame.png?raw=true)

When stacks are switched during a long-mode privilege-level change resulting from an interrupt, a new SS descriptor is not loaded from the TSS. Long mode only loads an inner-level RSP from the TSS. However, the SS selector is loaded with a null selector, allowing nested control transfers, including interrupts, to be handled properly in 64-bit mode. The SS.RPL is set to the new CPL value.

![avatar](https://raw.githubusercontent.com/arafatms/arafatms.github.io/main/images/posts/20210923-AMDExceptionsAndInterrupts/LongModeStackAfterInterruptHigher.png?raw=true)

### Interrupt Stack Table
In long mode, a new interrupt-stack table (IST) mechanism is introduced as an alternative to the modified legacy stack-switch mechanism described above. The IST mechanism provides a method for specific interrupts, such as NMI, double-fault, and machine-check, to always execute on a knowngood stack.
也就是说里用描述符中记录的IST，制定目标RSP。

### Returning From Interrupt Procedures
a return to an interrupted program in long mode should be performed using the IRET instruction.
